package Datastore::Memory;

use base qw(Datastore);

use strict;
use warnings FATAL => 'all';

# Fields
# _datastore - hashref of id => data
# _next_id - int of the next id to assign
# _indexes - implements an index, data values can be indexed to multiple ids
#  hashref of indexes: indexname => index;
#  each index is a hashref: indexvalue => data_id
# _unique_indexes - implements a unique index, data values can be indexed to a single id
#  hashref of indexes: indexname => index;
#  each index is a hashref: indexvalue => data_ids; data_ids is an arrayref

sub new {
   my ($class) = @_;

   my $self = bless {}, $class;
   $self->_datastore( {} );
   $self->_next_id(1);
   $self->_indexes( {} );

   return $self;
}

# adds an index to the datastore, assumes
sub add_unique_index {
   my ( $self, $indexname ) = @_;

   die "not implemented to add indexes to existing data"
      if keys %{ $self->_datastore };

   $self->_unique_indexes->{$indexname} = {};
}

sub add_index {
   my ( $self, $indexname ) = @_;

   die "not implemented to add indexes to existing data"
      if keys %{ $self->_datastore };

   $self->_indexes->{$indexname} = {};
}

sub retrieve {
   my ( $self, $id ) = @_;

   return $self->_datastore->{$id};
}

sub retrieve_all {
   my ($self) = @_;
   return $self->_datastore;
}

sub insert {
   my ( $self, $data ) = @_;

   $self->_increment_next_id;
   my $id = $self->_next_id;

   $self->_datastore->{$id} = $data;

   $self->_add_index_values( $id, $data );

   return $id;
}

sub replace {
   my ( $self, $id, $data ) = @_;

   my $old_data = $self->_datastore->{$id};
   $self->_delete_index_values( $id, $old_data );

   $self->_datastore->{$id} = $data;

   $self->_add_index_values( $id, $data );

   return;
}

sub delete {
   my ( $self, $id ) = @_;

   my $data = delete $self->_datastore->{$id};
   $self->_delete_index_values( $id, $data );
   return;
}

# searches in the $index_name unique index for the $indexed_value
sub get_id_by_unique_index {
   my ( $self, $indexed_value, $index_name ) = @_;

   die "No unique index named $index_name"
      if !$self->_unique_indexes->{$index_name};
   return $self->_unique_indexes->{$index_name}->{$indexed_value};
}

# searches in the $index_name index for the $indexed_value, returns array ref
#  of all ids found in the index for the indexed_value
sub get_ids_by_index {
   my ( $self, $indexed_value, $index_name ) = @_;

   die "No index named $index_name"
      if !$self->_indexes->{$index_name};
   return [ keys %{ $self->_indexes->{$index_name}->{$indexed_value} } ];
}

sub _increment_next_id {
   my ($self) = @_;

   $self->_next_id( $self->_next_id + 1 );

   # avoid collisions
   $self->_increment_next_id
      if $self->retrieve( $self->_next_id );

   return;
}

# deletes from all indexes the keys associated with each key in $data
sub _delete_index_values {
   my ( $self, $id, $data ) = @_;

   while ( my ( $idx_name, $index ) = each %{ $self->_unique_indexes } ) {
      delete $index->{ $data->{$idx_name} }
         if defined $data->{$idx_name};
   }

INDEX:
   while ( my ( $idx_name, $index ) = each %{ $self->_indexes } ) {
      delete $index->{ $data->{$idx_name} }->{$id};

      delete $index->{ $data->{$idx_name} }
         if !keys %{ $index->{ $data->{$idx_name} } };
   }
}

sub _add_index_values {
   my ( $self, $id, $data ) = @_;

   while ( my ( $idx_name, $index ) = each %{ $self->_unique_indexes } ) {
      $index->{ $data->{$idx_name} } = $id
         if defined $data->{$idx_name};
   }

   while ( my ( $idx_name, $index ) = each %{ $self->_indexes } ) {
      $index->{ $data->{$idx_name} } ||= {};

      $index->{ $data->{$idx_name} }->{$id} = 1;
   }
}

# accessors
sub _datastore {
   my ( $self, $val ) = @_;

   if ( @_ == 2 ) {
      $self->{datastore} = $val;
   }

   return $self->{datastore};
}

sub _next_id {
   my ( $self, $val ) = @_;

   if ( @_ == 2 ) {
      $self->{next_id} = $val;
   }

   return $self->{next_id};
}

sub _unique_indexes {
   my ( $self, $val ) = @_;

   if ( @_ == 2 ) {
      $self->{_unique_indexes} = $val;
   }

   return $self->{_unique_indexes};
}

sub _indexes {
   my ( $self, $val ) = @_;

   if ( @_ == 2 ) {
      $self->{_indexes} = $val;
   }

   return $self->{_indexes};
}

1;
